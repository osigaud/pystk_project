Notre but est faire un kart qui avance et toujours rester au milieu de path et aller jusqu'à	 la fin:

1. Nous avons créer une fonction "position_track" qui per mettre de scanner la route devant et renvoyer le vecteur (x(gauche ou droit), z(devant ou dernier)).

2. Nous avons créer une fonction "compute_turning" qui prendre valeur x et z, qui sont les deux valeurs renvoyer par la fonction "position_track" qui permettre de calculer l'angle de braquage avec (x, z).

3. Nous avons créer une fonction "manage_speed_rescue" qui permettre de gérer l'accélération	, freinage et anti-blocage.

-> 1 position_track:
Pour avoir les vecteur de la route devant le kart il faut d'abord trouver la liste de tous les paths_end en vecteur ( les points d'arriver de tous les paths), ensuite on prendre la vecteur le plus loin pour que on peut anticiper les virages plus loins, puis on parcourir tous les vecteurs de paths et prendre leur valeur z(devant = distance), si la distance est plus grande que self.LOOKAHEAD_DIST(on a défini tout debut qui est égale a 10(mètre)) après on remplace la vecteur plus loins par la prochaine vecteur qui se situe au moins 10 mètre plus loins de nous puis on renvoyer ses x et z pour la prochaine fonction.

-> 2 compute_turning:
On met d'abord le min de z a 0.5 pour que quand on fait la calcule error_angle la valeur de retour ne soyez pas tres grand	sino on perde le contrôle	 de braquage, ensuite on fait la calcule tangente x/z avec x est opposé et z adjacent qui renvoyer un valeur qui est inférieur de 1 et qui est le radian. Puis on calcule la différence entre erreur d'avant et erreur actuel pour trouver le toux de variation, Pour mettre la braquage de notre kart plus stable on doit utiliser "(error_angle * self.Kp) + (derivative * self.Kd)" "error_angle * self.Kp" pour corriger l'erreur actuel et "derivative * self.Kd" pour contrôler la variation de l'erreur. Puis on limiter la valeur de steering_war en -1 et 1, puis on le return.

-> 3 manage_speed_rescue: 
Pour gérer la vitesse du kart et reculer quand il est bloqué, on commence par récupérer le vecteur de vitesse, puis on calcule la vitesse réelle du kart avec "np.linalg.norm(velocity)" (sqrt(x^2 + y^2 + z^2)).
On initialise d'abord l'accélération à 1 et le freinage à False, ensuite on vérifie si la valeur de steering a une valeur absolu supérieur à 0.3, si oui on réduit l'accélération à 0.5. pour éviter que le kart tourne avec une vitesse trop vite. On initialise la variable	"is_stuck" à False, pour verifier is le kart est bloqué, on vérifie deux conditions: 
	"obs['distance_down_track'] > 5.0": le kart a parkour plus de 5 mètres depuis le depart;
	"speed < 0.5": la vitesse du kart est presque nulle.
Si ces deux conditions sont verifier, "self.stuck_counter" va plus 1, si le compteur dépasse de 30, on peut dire que il est bloqué(is_stuck = True), sinon on réinitialise le compteur à 0.
Si le kart est bloqué, on met l'accélération à 0, on active le freinage, on inverse la valeur de braquage(steering = -steering) pour que le kart se dégage du mur. Finalement on renvoie les valeur d'accélération, de freinage et le braquage corrigé pour la fonction "choose_action".
