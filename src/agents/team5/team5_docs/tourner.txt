1er version: avec des zone gauche droit et milieu:

import numpy as np
import random

from utils.track_utils import compute_curvature, compute_slope
from agents.kart_agent import KartAgent


class Agent4(KartAgent):
    def __init__(self, env, path_lookahead=3):
        super().__init__(env)
        self.path_lookahead = path_lookahead
        self.agent_positions = []
        self.obs = None
        self.isEnd = False
        self.name = "Team5" # replace with your chosen name

        self.dernier_distance_centre = 0

    def reset(self):
        self.obs, _ = self.env.reset()
        self.agent_positions = []

    def endOfTrack(self):
        return self.isEnd

    def choose_action(self, obs):
        centre = obs['center_path_distance'][0]   # positif = droite, négatif = gauche
        width = obs['paths_width'][0]             # largeur de la piste

        # si est dans la zone millieu ne pas tourner pour éviter les oscillations
        zone_milieur = width / 5.5
        if abs(centre) < zone_milieur:
            steer = 0.0
        else:
            # plus loin du centre = plus grand virage
            # multiplié par un valeur pour rester doux. 0.22 peut changer
            erreur = centre * 0.22

            # ajouter un peu de la différence précédente pour éviter les virages brusques
            diff = (centre - self.dernier_distance_centre) * 0.3 # 0.3 peut changer
            steer = -(erreur + diff)   # Signe négatif = tourner à gauche
        # limiter entre -0.5 et 0.5 . les deux valeurs peuvent changer
        if steer > 0.5:
            steer = 0.5
        if steer < -0.5:
            steer = -0.5

        # mettre à jour le dernier distance centre pour prochaine calcule
        self.dernier_distance_centre = centre

        action = {
            "acceleration":0.3,
            "steer": steer,
            "brake": False, # bool(random.getrandbits(1))
            "drift": False,
            "nitro": False ,
            "rescue":bool(random.getrandbits(1)),
            "fire": False,
        }
        return action


2eme version: sans les zones:

import numpy as np
import random

from utils.track_utils import compute_curvature, compute_slope
from agents.kart_agent import KartAgent


class Agent6(KartAgent):
    def __init__(self, env, path_lookahead=3):
        super().__init__(env)
        self.path_lookahead = path_lookahead
        self.agent_positions = []
        self.obs = None
        self.isEnd = False
        self.name = "Team5" # replace with your chosen name
        self.dernier_distance_centre = 0.0

    def reset(self):
        self.obs, _ = self.env.reset()
        self.agent_positions = []
        
    def endOfTrack(self):
        return self.isEnd

    def choose_action(self, obs):
        distance_centre = obs['center_path_distance'][0]  # distance au centre 

        # si la distance est plus loin du centre, on tourne plus fort, avec un valeur de controle pour tourner doux
        erreur = 0.35 * distance_centre
        # la différence avec la dernière distance centre pour éviter les virages brusques
        diff = 0.77 * (distance_centre - self.dernier_distance_centre)
        # angle de tournage, lopposé avec la distance au centre, si la distance est positive (droite), on tourne à gauche etc.
        steer = -(erreur + diff)
        # min et max pour limiter les tourne trop forts
        steer = max(-0.6, min(0.6, steer))
        
        # 3. mettre en jour le dernier distance centre pour le prochaine calcule
        self.dernier_distance_centre = distance_centre
        brake = 0.0
        action = {
            "acceleration": 0.27,
            "steer": steer,
            "brake": brake,
            "drift": False,  
            "nitro": False,
            "rescue": bool(random.getrandbits(1)),
            "fire": bool(random.getrandbits(1)),
        }
        return action



